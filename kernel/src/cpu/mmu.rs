use core::arch::asm;
use core::ptr::{read_volatile, write_volatile};

use crate::println;

const TCR_CONFIG_REGION_48BIT: usize = ((64 - 48) << 0) | ((64 - 48) << 16);
const TCR_CONFIG_4KB: usize = (0b00 << 14) | (0b00 << 30);
const TCR_CONFIG_DEFAULT: usize = TCR_CONFIG_REGION_48BIT | TCR_CONFIG_4KB | (0b101usize << 32);

const MAIR_DEVICE_NG_NR_NE: usize = 0b00000000;
const MAIR_NORMAL_NOCACHE: usize = 0b01000100;
const MAIR_IDX_DEVICE_NG_NR_NE: usize = 0;
const MAIR_IDX_NORMAL_NOCACHE: usize = 1;
const MAIR_CONFIG_DEFAULT: usize = (MAIR_DEVICE_NG_NR_NE << (MAIR_IDX_DEVICE_NG_NR_NE * 8))
    | (MAIR_NORMAL_NOCACHE << (MAIR_IDX_NORMAL_NOCACHE * 8));

const PD_TABLE: usize = 0b11;
const PD_BLOCK: usize = 0b01;
const PD_ACCESS: usize = 1 << 10;
const AP_RW_EL0: usize = 0b01 << 6;

const BOOT_PGD_ATTR: usize = PD_TABLE;
const BOOT_PUD_ATTR_DEVICE: usize =
    PD_ACCESS | (0 << 6) | (MAIR_IDX_DEVICE_NG_NR_NE << 2) | PD_BLOCK;
const BOOT_PUD_ATTR_NORMAL: usize =
    PD_ACCESS | (0 << 6) | (MAIR_IDX_NORMAL_NOCACHE << 2) | PD_BLOCK;

const PGD_ADDRESS: usize = 0x2000;
const PUD_ADDRESS: usize = 0x3000;
const PMD_ADDRESS: usize = 0x4000;

unsafe fn add_entry() {}

/*
ESR_EL1
100100 1 0 ~ 0 1 001110
^      ^       ^ ^
|      |       | |
|      |       | Permission fault, level2
|      |       |
|      |       Abort caused by an instruction writing to a memory location.
|      |
|      32-bit instruction trap
|
EC: Data Abort exception from a lower Exception level.
Used for MMU faults generated by data accesses, alignment faults other than those caused by Stack Pointer misalignment, and synchronous External aborts, including synchronous parity or ECC errors. Not used for debug-related exceptions.
*/

#[no_mangle]
unsafe extern "C" fn setup_mmu() {
    // Initialize TCR
    asm!(
        "msr tcr_el1, {0}",
        in(reg) TCR_CONFIG_DEFAULT,
    );

    // Initialize MAIR
    asm!(
        "msr mair_el1, {0}",
        in(reg) MAIR_CONFIG_DEFAULT,
    );

    // Identity Paging
    write_volatile(PGD_ADDRESS as *mut usize, PUD_ADDRESS | BOOT_PGD_ATTR);
    write_volatile(
        PUD_ADDRESS as *mut usize,
        PMD_ADDRESS | PD_ACCESS | AP_RW_EL0 | (MAIR_IDX_NORMAL_NOCACHE << 2) | PD_TABLE,
    );
    write_volatile(
        (PUD_ADDRESS + 8) as *mut usize,
        0x40000000usize | BOOT_PUD_ATTR_DEVICE,
    );

    const PMD_SIZE: usize = 1024 * 1024 * 2;

    for i in 0..512 {
        let entry_address = (PMD_ADDRESS + i * 8) as *mut usize;
        let page_address = i * PMD_SIZE;

        if page_address < 0x1000 {
            write_volatile(
                entry_address,
                page_address | PD_ACCESS | (MAIR_IDX_NORMAL_NOCACHE << 2 | PD_BLOCK),
            );
        } else if page_address < 0x3C00_0000 {
            write_volatile(
                entry_address,
                page_address | PD_ACCESS | AP_RW_EL0 | (MAIR_IDX_NORMAL_NOCACHE << 2 | PD_BLOCK),
            );
        } else {
            write_volatile(
                entry_address,
                page_address | PD_ACCESS | (MAIR_IDX_DEVICE_NG_NR_NE << 2 | PD_BLOCK),
            );
        }
    }

    asm!("isb");

    asm!(
        "msr ttbr0_el1, {PGD_addr}",
        "msr ttbr1_el1, {PGD_addr}",

        PGD_addr = in(reg) PGD_ADDRESS,
    );

    // Enable MMU
    asm!(
        "mrs {tmp}, sctlr_el1",
        "orr {tmp}, {tmp}, 1",
        "msr sctlr_el1, {tmp}",
        tmp = out(reg) _,
    );
}

pub fn test() {}

pub fn map_pages() {}
